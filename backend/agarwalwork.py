# -*- coding: utf-8 -*-
"""Agarwalwork.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rytcI_JybMoQ02uhuD986zzkxQGq1Zo3
"""

# DATABASE & APTITUDE TESTING MODULE - TANISHA AGGARWAL
# 40% Implementation - Working Code

import sqlite3
import json
import random
from datetime import datetime
from typing import List, Dict, Optional
import hashlib
import pandas as pd

class DatabaseManager:
    """Database management for career counseling system"""

    def __init__(self, db_name='career_counseling.db'):
        self.db_name = db_name
        self.conn = None
        self.cursor = None
        self.connect()
        self.create_tables()

    def connect(self):
        """Establish database connection"""
        self.conn = sqlite3.connect(self.db_name)
        self.cursor = self.conn.cursor()

    def create_tables(self):
        """Create all necessary tables"""

        # Users table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                full_name TEXT,
                age INTEGER,
                education_level TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # Aptitude tests table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS aptitude_tests (
                test_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                test_type TEXT,
                score REAL,
                completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')

        # Test questions table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS questions (
                question_id INTEGER PRIMARY KEY AUTOINCREMENT,
                category TEXT NOT NULL,
                difficulty TEXT,
                question_text TEXT NOT NULL,
                options TEXT NOT NULL,
                correct_answer INTEGER NOT NULL,
                explanation TEXT
            )
        ''')

        # User responses table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_responses (
                response_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                test_id INTEGER,
                question_id INTEGER,
                user_answer INTEGER,
                is_correct BOOLEAN,
                time_taken INTEGER,
                FOREIGN KEY (user_id) REFERENCES users (user_id),
                FOREIGN KEY (test_id) REFERENCES aptitude_tests (test_id),
                FOREIGN KEY (question_id) REFERENCES questions (question_id)
            )
        ''')

        # Career recommendations table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS career_recommendations (
                recommendation_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                career_title TEXT,
                match_percentage REAL,
                reasoning TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')

        # Career profiles table
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS career_profiles (
                career_id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                category TEXT,
                description TEXT,
                required_skills TEXT,
                education_requirements TEXT,
                salary_range TEXT,
                growth_prospects TEXT
            )
        ''')

        self.conn.commit()

    def hash_password(self, password: str) -> str:
        """Hash password for security"""
        return hashlib.sha256(password.encode()).hexdigest()

    def add_user(self, username: str, email: str, password: str,
                 full_name: str = None, age: int = None,
                 education_level: str = None) -> int:
        """Add new user to database"""
        try:
            password_hash = self.hash_password(password)
            self.cursor.execute('''
                INSERT INTO users (username, email, password_hash, full_name, age, education_level)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (username, email, password_hash, full_name, age, education_level))
            self.conn.commit()
            return self.cursor.lastrowid
        except sqlite3.IntegrityError as e:
            print(f"Error adding user: {e}")
            return None

    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """Authenticate user login"""
        password_hash = self.hash_password(password)
        self.cursor.execute('''
            SELECT user_id, username, email, full_name
            FROM users
            WHERE username = ? AND password_hash = ?
        ''', (username, password_hash))

        result = self.cursor.fetchone()
        if result:
            return {
                'user_id': result[0],
                'username': result[1],
                'email': result[2],
                'full_name': result[3]
            }
        return None

    def save_test_result(self, user_id: int, test_type: str, score: float) -> int:
        """Save aptitude test result"""
        self.cursor.execute('''
            INSERT INTO aptitude_tests (user_id, test_type, score)
            VALUES (?, ?, ?)
        ''', (user_id, test_type, score))
        self.conn.commit()
        return self.cursor.lastrowid

    def get_user_test_history(self, user_id: int) -> List[Dict]:
        """Get test history for a user"""
        self.cursor.execute('''
            SELECT test_id, test_type, score, completed_at
            FROM aptitude_tests
            WHERE user_id = ?
            ORDER BY completed_at DESC
        ''', (user_id,))

        results = []
        for row in self.cursor.fetchall():
            results.append({
                'test_id': row[0],
                'test_type': row[1],
                'score': row[2],
                'completed_at': row[3]
            })
        return results

    def close(self):
        """Close database connection"""
        if self.conn:
            self.conn.close()

class AptitudeTestManager:
    """Manage aptitude tests and questions"""

    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager
        self.load_sample_questions()

    def load_sample_questions(self):
        """Load sample aptitude questions into database"""

        sample_questions = [
            # Logical Reasoning
            {
                'category': 'logical_reasoning',
                'difficulty': 'easy',
                'question': 'What comes next: 2, 4, 8, 16, ?',
                'options': ['20', '24', '32', '36'],
                'correct_answer': 2,
                'explanation': 'Each number is multiplied by 2'
            },
            {
                'category': 'logical_reasoning',
                'difficulty': 'medium',
                'question': 'If all roses are flowers and some flowers fade quickly, then:',
                'options': [
                    'All roses fade quickly',
                    'Some roses fade quickly',
                    'No roses fade quickly',
                    'Cannot be determined'
                ],
                'correct_answer': 3,
                'explanation': 'We cannot determine if roses are among the flowers that fade quickly'
            },

            # Verbal Ability
            {
                'category': 'verbal_ability',
                'difficulty': 'easy',
                'question': 'Choose the correct spelling:',
                'options': ['Accomodate', 'Accommodate', 'Acommodate', 'Acomodate'],
                'correct_answer': 1,
                'explanation': 'The correct spelling is "Accommodate" with double c and double m'
            },
            {
                'category': 'verbal_ability',
                'difficulty': 'medium',
                'question': 'Choose the word most similar to "Eloquent":',
                'options': ['Silent', 'Articulate', 'Rude', 'Brief'],
                'correct_answer': 1,
                'explanation': 'Eloquent means fluent or persuasive in speaking, similar to articulate'
            },

            # Numerical Ability
            {
                'category': 'numerical_ability',
                'difficulty': 'easy',
                'question': 'What is 15% of 200?',
                'options': ['20', '25', '30', '35'],
                'correct_answer': 2,
                'explanation': '15% of 200 = 0.15 × 200 = 30'
            },
            {
                'category': 'numerical_ability',
                'difficulty': 'medium',
                'question': 'A train travels 360 km in 6 hours. What is its average speed?',
                'options': ['50 km/h', '60 km/h', '70 km/h', '80 km/h'],
                'correct_answer': 1,
                'explanation': 'Speed = Distance/Time = 360/6 = 60 km/h'
            },

            # Spatial Reasoning
            {
                'category': 'spatial_reasoning',
                'difficulty': 'easy',
                'question': 'How many faces does a cube have?',
                'options': ['4', '5', '6', '8'],
                'correct_answer': 2,
                'explanation': 'A cube has 6 faces'
            },

            # Abstract Reasoning
            {
                'category': 'abstract_reasoning',
                'difficulty': 'medium',
                'question': 'Find the pattern: A1, C3, E5, G7, ?',
                'options': ['H8', 'I9', 'J10', 'K11'],
                'correct_answer': 1,
                'explanation': 'Letters skip one (A,C,E,G,I) and numbers increase by 2 (1,3,5,7,9)'
            }
        ]

        # Insert questions into database
        for q in sample_questions:
            self.db.cursor.execute('''
                INSERT OR IGNORE INTO questions
                (category, difficulty, question_text, options, correct_answer, explanation)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (q['category'], q['difficulty'], q['question'],
                  json.dumps(q['options']), q['correct_answer'], q['explanation']))

        self.db.conn.commit()

    def get_test_questions(self, categories: List[str] = None,
                          num_questions: int = 10) -> List[Dict]:
        """Get random questions for a test"""

        if categories:
            placeholders = ','.join('?' * len(categories))
            query = f'''
                SELECT question_id, category, difficulty, question_text,
                       options, correct_answer, explanation
                FROM questions
                WHERE category IN ({placeholders})
                ORDER BY RANDOM()
                LIMIT ?
            '''
            self.db.cursor.execute(query, (*categories, num_questions))
        else:
            self.db.cursor.execute('''
                SELECT question_id, category, difficulty, question_text,
                       options, correct_answer, explanation
                FROM questions
                ORDER BY RANDOM()
                LIMIT ?
            ''', (num_questions,))

        questions = []
        for row in self.db.cursor.fetchall():
            questions.append({
                'question_id': row[0],
                'category': row[1],
                'difficulty': row[2],
                'question': row[3],
                'options': json.loads(row[4]),
                'correct_answer': row[5],
                'explanation': row[6]
            })

        return questions

    def evaluate_test(self, user_id: int, test_id: int,
                     responses: List[Dict]) -> Dict:
        """Evaluate test responses and calculate scores"""

        correct_count = 0
        category_scores = {}

        for response in responses:
            is_correct = response['user_answer'] == response['correct_answer']
            if is_correct:
                correct_count += 1

            # Track category-wise performance
            category = response['category']
            if category not in category_scores:
                category_scores[category] = {'correct': 0, 'total': 0}

            category_scores[category]['total'] += 1
            if is_correct:
                category_scores[category]['correct'] += 1

            # Save response to database
            self.db.cursor.execute('''
                INSERT INTO user_responses
                (user_id, test_id, question_id, user_answer, is_correct, time_taken)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (user_id, test_id, response['question_id'],
                  response['user_answer'], is_correct, response.get('time_taken', 0)))

        self.db.conn.commit()

        # Calculate overall score
        overall_score = (correct_count / len(responses)) * 100

        # Calculate category-wise percentages
        for category in category_scores:
            cat_data = category_scores[category]
            cat_data['percentage'] = (cat_data['correct'] / cat_data['total']) * 100

        return {
            'overall_score': overall_score,
            'correct_answers': correct_count,
            'total_questions': len(responses),
            'category_scores': category_scores
        }

    def generate_career_recommendations(self, user_id: int,
                                      test_results: Dict) -> List[Dict]:
        """Generate career recommendations based on test results"""

        recommendations = []
        category_scores = test_results['category_scores']

        # Career mapping based on aptitude strengths
        career_mapping = {
            'logical_reasoning': [
                {'title': 'Software Developer', 'match': 0.9},
                {'title': 'Data Analyst', 'match': 0.85},
                {'title': 'Systems Analyst', 'match': 0.8}
            ],
            'verbal_ability': [
                {'title': 'Content Writer', 'match': 0.9},
                {'title': 'Teacher', 'match': 0.85},
                {'title': 'Journalist', 'match': 0.8}
            ],
            'numerical_ability': [
                {'title': 'Accountant', 'match': 0.9},
                {'title': 'Financial Analyst', 'match': 0.85},
                {'title': 'Statistician', 'match': 0.8}
            ],
            'spatial_reasoning': [
                {'title': 'Architect', 'match': 0.9},
                {'title': 'Graphic Designer', 'match': 0.85},
                {'title': 'Engineer', 'match': 0.8}
            ],
            'abstract_reasoning': [
                {'title': 'Research Scientist', 'match': 0.9},
                {'title': 'Strategic Planner', 'match': 0.85},
                {'title': 'Business Analyst', 'match': 0.8}
            ]
        }

        # Find top performing categories
        sorted_categories = sorted(category_scores.items(),
                                 key=lambda x: x[1]['percentage'],
                                 reverse=True)

        for category, scores in sorted_categories[:2]:
            if scores['percentage'] >= 60:  # Only recommend if score is decent
                if category in career_mapping:
                    for career in career_mapping[category]:
                        match_percentage = career['match'] * scores['percentage']
                        recommendations.append({
                            'career_title': career['title'],
                            'match_percentage': match_percentage,
                            'reasoning': f"Strong performance in {category.replace('_', ' ')}"
                        })

        # Save recommendations to database
        for rec in recommendations[:5]:  # Top 5 recommendations
            self.db.cursor.execute('''
                INSERT INTO career_recommendations
                (user_id, career_title, match_percentage, reasoning)
                VALUES (?, ?, ?, ?)
            ''', (user_id, rec['career_title'], rec['match_percentage'], rec['reasoning']))

        self.db.conn.commit()

        return recommendations[:5]

# Testing and demonstration code
def test_database_module():
    """Test the database and testing module"""

    print("="*50)
    print("DATABASE & APTITUDE TESTING MODULE - 40% IMPLEMENTATION")
    print("="*50)

    # Initialize database
    db = DatabaseManager('test_career.db')
    test_manager = AptitudeTestManager(db)

    # Create a test user
    print("\n1. Creating test user...")
    user_id = db.add_user(
        username="test_student",
        email="student@test.com",
        password="password123",
        full_name="Test Student",
        age=17,
        education_level="12th Grade"
    )

    if user_id:
        print(f"   ✓ User created with ID: {user_id}")

    # Authenticate user
    print("\n2. Testing authentication...")
    user = db.authenticate_user("test_student", "password123")
    if user:
        print(f"   ✓ User authenticated: {user['username']}")

    # Get test questions
    print("\n3. Loading aptitude test questions...")
    questions = test_manager.get_test_questions(num_questions=5)
    print(f"   ✓ Loaded {len(questions)} questions")

    # Simulate test responses
    print("\n4. Simulating test responses...")
    test_id = db.save_test_result(user_id, "General Aptitude", 0)

    responses = []
    for i, q in enumerate(questions):
        # Simulate user answering (randomly for demo)
        user_answer = random.randint(0, 3)
        responses.append({
            'question_id': q['question_id'],
            'category': q['category'],
            'user_answer': user_answer,
            'correct_answer': q['correct_answer'],
            'time_taken': random.randint(10, 60)
        })

        print(f"   Q{i+1}: {q['question'][:50]}...")
        print(f"        User answered: Option {user_answer+1}")

    # Evaluate test
    print("\n5. Evaluating test results...")
    results = test_manager.evaluate_test(user_id, test_id, responses)

    print(f"   Overall Score: {results['overall_score']:.1f}%")
    print(f"   Correct Answers: {results['correct_answers']}/{results['total_questions']}")

    print("\n   Category-wise Performance:")
    for category, scores in results['category_scores'].items():
        print(f"   - {category.replace('_', ' ').title()}: {scores['percentage']:.1f}%")

    # Generate recommendations
    print("\n6. Generating career recommendations...")
    recommendations = test_manager.generate_career_recommendations(user_id, results)

    print("   Top Career Recommendations:")
    for i, rec in enumerate(recommendations, 1):
        print(f"   {i}. {rec['career_title']} (Match: {rec['match_percentage']:.1f}%)")
        print(f"      Reason: {rec['reasoning']}")

    # Get test history
    print("\n7. Retrieving test history...")
    history = db.get_user_test_history(user_id)
if __name__ == "__main__":
    test_database_module() # Indented with 4 spaces

